"""
Vulnerability Service - Image Security Scanning
Uses Trivy to scan Docker images for CVEs and vulnerabilities
"""
import json
import subprocess
import shutil
import time
import logging
import sys
from datetime import datetime
from typing import Optional, Dict, Any, List

# Configure logging
logger = logging.getLogger('vulnerability_scanner')
logger.setLevel(logging.DEBUG)  # Capture all levels, filter at handler

# Stream handler for Docker logs
if not logger.handlers:
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(logging.Formatter(
        '[%(asctime)s] [SCANNER] [%(levelname)s] %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    ))
    logger.addHandler(handler)


def _get_log_level() -> int:
    """Get current log level from settings."""
    try:
        from models import ScanSettings
        settings = ScanSettings.get_settings()
        level_str = getattr(settings, 'log_level', 'INFO') or 'INFO'
        return getattr(logging, level_str.upper(), logging.INFO)
    except Exception:
        return logging.INFO


def _log(level: int, message: str):
    """Log message if level meets threshold."""
    if level >= _get_log_level():
        logger.log(level, message)


# Cache for scan results (image -> (timestamp, results))
_scan_cache: Dict[str, tuple] = {}
CACHE_TTL = 3600  # 1 hour

# Scan status tracking
_scan_in_progress = False
_current_scan_image = None
_scan_progress = {'total': 0, 'completed': 0, 'current': None}


def _cache_get(key: str) -> Optional[Dict]:
    """Get cached scan result if not expired."""
    entry = _scan_cache.get(key)
    if not entry:
        return None
    ts, value = entry
    if (time.time() - ts) > CACHE_TTL:
        _scan_cache.pop(key, None)
        return None
    return value


def _cache_set(key: str, value: Dict):
    """Cache scan result."""
    _scan_cache[key] = (time.time(), value)


def is_trivy_available() -> bool:
    """Check if Trivy is installed and available."""
    return shutil.which('trivy') is not None


def scan_image(image_ref: str, severity_filter: str = "CRITICAL,HIGH") -> Dict[str, Any]:
    """
    Scan a Docker image for vulnerabilities using Trivy.
    
    Args:
        image_ref: Docker image reference (e.g., 'nginx:latest')
        severity_filter: Comma-separated severity levels (CRITICAL,HIGH,MEDIUM,LOW)
    
    Returns:
        Dictionary with scan results including vulnerabilities found
    """
    _log(logging.INFO, f"Starting scan for image: {image_ref}")
    _log(logging.DEBUG, f"Severity filter: {severity_filter}")
    
    result = {
        'image': image_ref,
        'success': False,
        'scanner': 'trivy',
        'vulnerabilities': [],
        'summary': {
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'unknown': 0,
            'total': 0
        },
        'error': None
    }
    
    if not image_ref or image_ref == 'unknown':
        _log(logging.WARNING, f"Invalid image reference: {image_ref}")
        result['error'] = 'Invalid image reference'
        return result
    
    # Check cache first
    cache_key = f"{image_ref}:{severity_filter}"
    cached = _cache_get(cache_key)
    if cached:
        _log(logging.DEBUG, f"Using cached result for {image_ref}")
        return cached
    
    if not is_trivy_available():
        _log(logging.ERROR, "Trivy scanner not installed")
        result['error'] = 'Trivy scanner not installed. Install with: brew install trivy (macOS) or see https://trivy.dev'
        return result
    
    try:
        # Run Trivy scan with JSON output
        cmd = [
            'trivy', 'image',
            '--format', 'json',
            '--severity', severity_filter,
            image_ref
        ]
        
        _log(logging.DEBUG, f"Running command: {' '.join(cmd)}")
        start_time = time.time()
        
        proc = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=300  # 5 minute timeout
        )
        
        elapsed = time.time() - start_time
        _log(logging.DEBUG, f"Trivy command completed in {elapsed:.1f}s (exit code: {proc.returncode})")
        
        if proc.stderr:
            _log(logging.DEBUG, f"Trivy stderr: {proc.stderr[:500]}")
        
        if proc.returncode != 0 and not proc.stdout:
            _log(logging.ERROR, f"Trivy scan failed for {image_ref}: {proc.stderr}")
            result['error'] = proc.stderr or 'Trivy scan failed'
            return result
        
        # Parse Trivy JSON output
        _log(logging.DEBUG, f"Parsing JSON output ({len(proc.stdout)} bytes)")
        scan_data = json.loads(proc.stdout) if proc.stdout else {}
        
        # Extract vulnerabilities from results
        vulnerabilities = []
        summary = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'unknown': 0, 'total': 0}
        
        results_list = scan_data.get('Results', [])
        for target in results_list:
            target_name = target.get('Target', 'unknown')
            target_type = target.get('Type', 'unknown')
            
            for vuln in target.get('Vulnerabilities', []) or []:
                severity = vuln.get('Severity', 'UNKNOWN').lower()
                
                vuln_entry = {
                    'id': vuln.get('VulnerabilityID', ''),
                    'package': vuln.get('PkgName', ''),
                    'version': vuln.get('InstalledVersion', ''),
                    'fixed_version': vuln.get('FixedVersion', ''),
                    'severity': severity.upper(),
                    'title': vuln.get('Title', ''),
                    'description': vuln.get('Description', '')[:200] if vuln.get('Description') else '',
                    'target': target_name,
                    'type': target_type,
                    'cvss_score': _extract_cvss_score(vuln),
                    'references': vuln.get('References', [])[:3]  # Limit references
                }
                vulnerabilities.append(vuln_entry)
                
                if severity in summary:
                    summary[severity] += 1
                else:
                    summary['unknown'] += 1
                summary['total'] += 1
        
        result['success'] = True
        result['vulnerabilities'] = vulnerabilities
        result['summary'] = summary
        result['scanned_at'] = time.strftime('%Y-%m-%d %H:%M:%S')
        
        _log(logging.INFO, f"Scan complete for {image_ref}: {summary['critical']}C/{summary['high']}H/{summary['medium']}M/{summary['low']}L ({summary['total']} total)")
        
        # Cache successful results
        _cache_set(cache_key, result)
        
    except subprocess.TimeoutExpired:
        _log(logging.ERROR, f"Scan timed out for {image_ref} after 5 minutes")
        result['error'] = 'Scan timed out after 5 minutes'
    except json.JSONDecodeError as e:
        _log(logging.ERROR, f"Failed to parse Trivy output for {image_ref}: {e}")
        result['error'] = f'Failed to parse scan results: {e}'
    except Exception as e:
        _log(logging.ERROR, f"Scan error for {image_ref}: {e}")
        result['error'] = str(e)
    
    return result


def _extract_cvss_score(vuln: Dict) -> Optional[float]:
    """Extract CVSS score from vulnerability data."""
    # Try CVSS v3 first, then v2
    cvss = vuln.get('CVSS', {})
    for source in cvss.values():
        if 'V3Score' in source:
            return source['V3Score']
        if 'V2Score' in source:
            return source['V2Score']
    return None


def scan_multiple_images(image_refs: list, severity_filter: str = "CRITICAL,HIGH") -> Dict[str, Any]:
    """Scan multiple images and return aggregated results."""
    results = {}
    total_summary = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'unknown': 0, 'total': 0}
    
    for image_ref in image_refs[:10]:  # Limit to 10 images
        scan_result = scan_image(image_ref, severity_filter)
        results[image_ref] = scan_result
        
        if scan_result.get('success'):
            for key in total_summary:
                total_summary[key] += scan_result['summary'].get(key, 0)
    
    return {
        'success': True,
        'results': results,
        'total_summary': total_summary,
        'images_scanned': len(results)
    }


def get_vulnerability_report(image_ref: str) -> Dict[str, Any]:
    """Get a formatted vulnerability report for an image."""
    scan = scan_image(image_ref)
    
    if not scan['success']:
        return scan
    
    # Group vulnerabilities by severity
    by_severity = {'CRITICAL': [], 'HIGH': [], 'MEDIUM': [], 'LOW': [], 'UNKNOWN': []}
    
    for vuln in scan['vulnerabilities']:
        sev = vuln['severity']
        if sev in by_severity:
            by_severity[sev].append(vuln)
        else:
            by_severity['UNKNOWN'].append(vuln)
    
    scan['by_severity'] = by_severity
    scan['has_critical'] = len(by_severity['CRITICAL']) > 0
    scan['has_high'] = len(by_severity['HIGH']) > 0
    scan['needs_attention'] = scan['has_critical'] or scan['has_high']
    
    return scan


def clear_cache():
    """Clear the vulnerability scan cache."""
    global _scan_cache
    _scan_cache = {}
    return {'success': True, 'message': 'Cache cleared'}


def clear_image_cache(image_ref: str):
    """Clear cache for a specific image."""
    global _scan_cache
    # Remove all cache entries for this image (with any severity filter)
    keys_to_remove = [k for k in _scan_cache.keys() if k.startswith(f"{image_ref}:")]
    for k in keys_to_remove:
        _scan_cache.pop(k, None)


def scan_container_image(container_id: str, force: bool = False) -> Dict[str, Any]:
    """
    Scan the image for a specific container.
    
    Args:
        container_id: Container ID or name
        force: If True, clear cache and force fresh scan
    
    Returns:
        Dictionary with scan results
    """
    from services.docker_service import get_docker_client
    
    client = get_docker_client()
    if not client:
        return {'success': False, 'error': 'Docker not available'}
    
    if not is_trivy_available():
        return {'success': False, 'error': 'Trivy scanner not installed'}
    
    try:
        container = client.containers.get(container_id)
        
        # Get the actual image reference (with tag/version)
        image_ref = None
        if container.image.tags:
            image_ref = container.image.tags[0]
        else:
            # Use image ID if no tags
            image_ref = container.image.short_id
        
        if not image_ref:
            return {'success': False, 'error': 'Cannot determine image for container'}
        
        # Clear cache for this image if forcing
        if force:
            clear_image_cache(image_ref)
        
        # Scan the image
        start_time = time.time()
        scan_result = scan_image(image_ref, 'CRITICAL,HIGH,MEDIUM,LOW')
        duration = time.time() - start_time
        
        # Save to database
        save_scan_result(image_ref, scan_result, duration)
        
        return {
            'success': True,
            'container_id': container.short_id,
            'container_name': container.name,
            'image': image_ref,
            'scan_result': scan_result.get('summary') if scan_result.get('success') else None,
            'error': scan_result.get('error') if not scan_result.get('success') else None
        }
        
    except Exception as e:
        return {'success': False, 'error': str(e)}


def get_scan_status():
    """Get current scan progress."""
    return {
        'in_progress': _scan_in_progress,
        'current_image': _current_scan_image,
        'progress': _scan_progress.copy()
    }


def save_scan_result(image_ref: str, scan_result: Dict[str, Any], duration: float = None):
    """Save scan result to database."""
    from config import db
    from models import ImageVulnerability
    
    try:
        # Find existing or create new
        vuln = ImageVulnerability.query.filter_by(image_ref=image_ref).first()
        if not vuln:
            vuln = ImageVulnerability(image_ref=image_ref)
            db.session.add(vuln)
        
        if scan_result.get('success'):
            summary = scan_result.get('summary', {})
            vuln.critical_count = summary.get('critical', 0)
            vuln.high_count = summary.get('high', 0)
            vuln.medium_count = summary.get('medium', 0)
            vuln.low_count = summary.get('low', 0)
            vuln.total_count = summary.get('total', 0)
            vuln.error = None
            
            # Store full vulnerability details as JSON
            vulnerabilities = scan_result.get('vulnerabilities', [])
            if vulnerabilities:
                vuln.vulnerabilities_json = json.dumps(vulnerabilities)
            else:
                vuln.vulnerabilities_json = None
        else:
            vuln.error = scan_result.get('error', 'Unknown error')
        
        vuln.scanned_at = datetime.utcnow()
        vuln.scan_duration_seconds = duration
        db.session.commit()
        return True
    except Exception as e:
        _log(logging.ERROR, f"Error saving scan result: {e}")
        return False


def get_stored_vulnerabilities() -> Dict[str, Dict]:
    """Get all stored vulnerability scan results."""
    from models import ImageVulnerability
    
    try:
        vulns = ImageVulnerability.query.all()
        return {v.image_ref: v.to_dict() for v in vulns}
    except Exception:
        return {}


def get_image_vulnerability(image_ref: str) -> Optional[Dict]:
    """Get stored vulnerability data for a specific image."""
    from models import ImageVulnerability
    
    try:
        vuln = ImageVulnerability.query.filter_by(image_ref=image_ref).first()
        return vuln.to_dict() if vuln else None
    except Exception:
        return None


def scan_all_container_images(severity_filter: str = None) -> Dict[str, Any]:
    """Scan all images used by current containers."""
    global _scan_in_progress, _current_scan_image, _scan_progress
    
    _log(logging.INFO, "=== Starting full vulnerability scan ===")
    
    if _scan_in_progress:
        _log(logging.WARNING, "Scan already in progress, aborting")
        return {'success': False, 'error': 'Scan already in progress'}
    
    from services.docker_service import get_docker_client
    
    # Get severity filter from settings if not provided
    if not severity_filter:
        try:
            from models import ScanSettings
            settings = ScanSettings.get_settings()
            severity_filter = settings.severity_filter or 'CRITICAL,HIGH,MEDIUM,LOW'
        except Exception as e:
            _log(logging.WARNING, f"Could not load scan settings: {e}")
            severity_filter = 'CRITICAL,HIGH,MEDIUM,LOW'
    
    _log(logging.DEBUG, f"Using severity filter: {severity_filter}")
    
    client = get_docker_client()
    if not client:
        _log(logging.ERROR, "Docker client not available")
        return {'success': False, 'error': 'Docker not available'}
    
    if not is_trivy_available():
        _log(logging.ERROR, "Trivy scanner not found in PATH")
        return {'success': False, 'error': 'Trivy scanner not installed. Install with: brew install trivy (macOS) or see https://trivy.dev'}
    
    # Collect unique images from all containers
    try:
        containers = client.containers.list(all=True)
        image_set = set()
        for c in containers:
            if c.image.tags:
                image_set.add(c.image.tags[0])
        
        images = list(image_set)
        _log(logging.INFO, f"Found {len(images)} unique images to scan from {len(containers)} containers")
        
        if not images:
            return {'success': True, 'message': 'No container images to scan', 'scanned': 0}
        
        _scan_in_progress = True
        _scan_progress = {'total': len(images), 'completed': 0, 'current': None}
        
        # Update scan settings with start time (optional - don't fail scan if this fails)
        try:
            from config import db
            from models import ScanSettings
            settings = ScanSettings.get_settings()
            settings.last_scan_started = datetime.utcnow()
            settings.last_scan_images_count = len(images)
            db.session.commit()
        except Exception as e:
            _log(logging.WARNING, f"Could not update scan start time: {e}")
        
        results = {}
        total_summary = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'total': 0}
        scan_start_time = time.time()
        
        for i, image_ref in enumerate(images):
            _current_scan_image = image_ref
            _scan_progress['current'] = image_ref
            _scan_progress['completed'] = i
            
            _log(logging.INFO, f"Scanning image {i+1}/{len(images)}: {image_ref}")
            
            start_time = time.time()
            scan_result = scan_image(image_ref, severity_filter)
            duration = time.time() - start_time
            
            _log(logging.DEBUG, f"Image {image_ref} scanned in {duration:.1f}s")
            
            # Save to database
            save_scan_result(image_ref, scan_result, duration)
            
            results[image_ref] = {
                'success': scan_result.get('success', False),
                'summary': scan_result.get('summary', {}),
                'error': scan_result.get('error')
            }
            
            if scan_result.get('success'):
                summary = scan_result.get('summary', {})
                for key in total_summary:
                    total_summary[key] += summary.get(key, 0)
        
        total_duration = time.time() - scan_start_time
        _log(logging.INFO, f"=== Scan complete! {len(images)} images in {total_duration:.1f}s ===")
        _log(logging.INFO, f"Total vulnerabilities: {total_summary['critical']}C/{total_summary['high']}H/{total_summary['medium']}M/{total_summary['low']}L")
        
        # Update scan settings with completion time (optional)
        try:
            from config import db
            from models import ScanSettings
            settings = ScanSettings.get_settings()
            settings.last_scan_completed = datetime.utcnow()
            db.session.commit()
        except Exception as e:
            _log(logging.WARNING, f"Could not update scan completion time: {e}")
        
        _scan_in_progress = False
        _current_scan_image = None
        _scan_progress = {'total': len(images), 'completed': len(images), 'current': None}
        
        return {
            'success': True,
            'images_scanned': len(images),
            'results': results,
            'total_summary': total_summary
        }
        
    except Exception as e:
        _scan_in_progress = False
        _current_scan_image = None
        return {'success': False, 'error': str(e)}


def get_scan_settings() -> Dict[str, Any]:
    """Get current scan schedule settings."""
    from models import ScanSettings
    settings = ScanSettings.get_settings()
    return {
        'enabled': settings.enabled,
        'schedule_type': settings.schedule_type,
        'schedule_hour': settings.schedule_hour,
        'schedule_minute': settings.schedule_minute,
        'schedule_day': settings.schedule_day,
        'severity_filter': settings.severity_filter,
        'log_level': getattr(settings, 'log_level', 'INFO') or 'INFO',
        'last_scan_started': settings.last_scan_started.isoformat() if settings.last_scan_started else None,
        'last_scan_completed': settings.last_scan_completed.isoformat() if settings.last_scan_completed else None,
        'last_scan_images_count': settings.last_scan_images_count
    }


def update_scan_settings(enabled: bool = None, schedule_type: str = None, 
                         schedule_hour: int = None, schedule_minute: int = None,
                         schedule_day: int = None, severity_filter: str = None,
                         log_level: str = None) -> Dict[str, Any]:
    """Update scan schedule settings."""
    from config import db
    from models import ScanSettings
    
    settings = ScanSettings.get_settings()
    
    if enabled is not None:
        settings.enabled = enabled
    if schedule_type is not None:
        settings.schedule_type = schedule_type
    if schedule_hour is not None:
        settings.schedule_hour = max(0, min(23, schedule_hour))
    if schedule_minute is not None:
        settings.schedule_minute = max(0, min(59, schedule_minute))
    if schedule_day is not None:
        settings.schedule_day = max(0, min(6, schedule_day))
    if severity_filter is not None:
        settings.severity_filter = severity_filter
    if log_level is not None and log_level in ('DEBUG', 'INFO', 'WARNING', 'ERROR'):
        settings.log_level = log_level
    
    db.session.commit()
    
    return {'success': True, 'settings': get_scan_settings()}


def should_run_scheduled_scan() -> bool:
    """Check if a scheduled vulnerability scan should run now."""
    from models import ScanSettings
    from datetime import datetime
    
    try:
        settings = ScanSettings.get_settings()
        if not settings.enabled:
            return False
        
        now = datetime.now()
        
        # Check if we're in the right time window (within 5 minutes)
        if now.hour != settings.schedule_hour:
            return False
        if abs(now.minute - settings.schedule_minute) > 5:
            return False
        
        # For weekly, check day of week
        if settings.schedule_type == 'weekly':
            if now.weekday() != settings.schedule_day:
                return False
        
        # Check if we already ran recently (within last hour)
        if settings.last_scan_completed:
            delta = now - settings.last_scan_completed
            if delta.total_seconds() < 3600:
                return False
        
        return True
    except Exception:
        return False


def run_scheduled_scan_if_due():
    """Run a scheduled scan if it's time."""
    if should_run_scheduled_scan():
        _log(logging.INFO, "Running scheduled vulnerability scan")
        scan_all_container_images()

